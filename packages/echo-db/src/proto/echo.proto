//
// Copyright 2020 DxOS
//

syntax = "proto3";

// TODO(burdon): map
// TODO(burdon): Any @type
// TODO(burdon): Struct (JSON)
// TODO(burdon): https://ipld.io
// https://developers.google.com/protocol-buffers/docs/proto3#json
// https://developers.google.com/protocol-buffers/docs/proto#updating

//
// This package defines messages that can be used to form composite data structures, and arbitrary mutations.
//
package dxos.echo;

//
// Value represents any scalar, collection, or composite data.
//
message Value {
  oneof Type {
    bool    isNull                    = 1;

    // TODO(burdon): "Value" suffix not required?
    bool    boolValue                 = 2;
    int32   intValue                  = 3;
    float   floatValue                = 4;
    string  stringValue               = 5;

    bytes   bytes                     = 10;
    string  timestamp                 = 11;   // https://en.wikipedia.org/wiki/Unix_time
    string  datetime                  = 12;   // https://en.wikipedia.org/wiki/ISO_8601 (e.g., "2019-10-25T18:48:16Z")

    Object  objectValue               = 20;
    Set     setValue                  = 21;
    Array   arrayValue                = 22;
  }
}

//
// Object represents a set of (possibly hierarchical) named properties.
//
// TODO(burdon): Rename Map.
// TODO(burdon): Ordered Map.
message Object {

  message KeyValue {
    string property                   = 1;
    Value value                       = 2;
  }

  // TODO(burdon): Rename properties?
  repeated KeyValue property          = 1;
}

//
// Array represents an ordered collection of value.
//
message Array {

  // Splice mutation semantics.
  // TODO(burdon): Position only makes sense if reference previous state (not just previous mutation).
  message Mutation {
    int32 position                    = 1;        // -1 to append.
    int32 delete                      = 2;
    repeated Value value              = 3;
  }

  repeated Value value                = 1;
}

//
// Set represents a collection of unique values.
// TODO(burdon): Limit to scalars (otherwise need to provide custom equivalence operators?)
//
message Set {

  message Mutation {
    enum Operation {
      ADD                             = 0;        // Default.
      REMOVE                          = 1;
    }

    Operation op                      = 1;
    Value value                       = 2;
  }

  repeated Value value                = 1;
}

//
// Generic mutation.
//
message ObjectMutation {
  string id                           = 1;
  string objectId                     = 2;

  // TODO(burdon): Currently ignored (generalize vector clock).
  string depends                      = 3;

  // TODO(burdon): Define array of hierarchical ObjectMutations.
  // Which should include array and set mutations (not just KeValue).

  oneof Apply {
    bool deleted                      = 10;     // TODO(burdon): Currently ignored.
    Object.KeyValue value             = 20;
    Array.Mutation array              = 21;     // TODO(burdon): Currently ignored.
    Set.Mutation set                  = 22;     // TODO(burdon): Currently ignored.
  }
}

message ObjectMutationSet {
  repeated ObjectMutation mutations   = 1;
}
